import psutil
import time
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.linear_model import LinearRegression
from datetime import datetime

data = []

# Coleta de dados
for _ in range(60):  # coleta por 1 min (1s intervalo)
    cpu = psutil.cpu_percent()
    mem = psutil.virtual_memory().percent
    timestamp = datetime.now().strftime("%H:%M:%S")
    data.append([timestamp, cpu, mem])
    time.sleep(1)

# Salvando dados
df = pd.DataFrame(data, columns=["Time", "CPU", "Memory"])
df.to_csv("monitoramento.csv", index=False)

# Gráficos
plt.plot(df["CPU"], label="CPU")
plt.plot(df["Memory"], label="Memória")
plt.legend()
plt.title("Uso de CPU e Memória")
plt.xlabel("Tempo (s)")
plt.ylabel("% Uso")
plt.savefig("grafico_monitoramento.png")
plt.close()

# -*- coding: utf-8 -*-
"""IAAM_250218_Projeto03-Completo.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RedpYN79NPZ2JqXdVxjjNsJg8k_ndQwe

# BASE DE DADOS

Inicialmente, importar a base e fazer os ajustes necessarios antes de iniciar a operação propriamente dita:
"""

# Importar a lib do Pandas Pd
import pandas as pd

# Determinar qual é a URL da minha base:
URL = "https://raw.githubusercontent.com/profviniciusheltai/AulaIA/refs/heads/main/Projeto03.csv"

# Define ma variavel dados todos os valores extraidos:
dados = pd.read_csv(URL)

# Imprime a base a fim de confirmar o resultado:
dados.head()

"""Renomeando a base (index):

*   "expected_hours" -> "horas_esperadas"
*   "price" -> "preco"
*   "unfinished" -> "nao_finalizado"

"""

# Criação de um dicionario de equivalencia:
mapa = {
    'expected_hours' : 'horas_esperadas',
    'price' : 'preco',
    'unfinished' : 'nao_finalizado'
 }

# Atribui novamente a dados com a renomeação do dicionario:
dados = dados.rename(columns=mapa)

# Apresenta o head inicial dos dados (confirmar):
dados.head()

# Apresenta os dados finais:
dados.tail()

"""Criar uma nova coluna chamada "finalizado" com a logica oposta de "nao_finalizado" (mapeado) e troca o 0 para 1 e 1 para 0;"""

# Dicionario de troca de 0 para 1 e 1 para 0:
troca = {
    0 : 1,
    1 : 0
}

# Aplicar o dicionario e atribuir numa nova coluna chamada "finalizado"
dados['finalizado'] = dados.nao_finalizado.map(troca)

# Apresenta o inicio da base:
dados.head()

# Apresenta o final da base:
dados.tail()

"""Importando o seaborn como o modulo sns e plotando a dispersão:"""

# Importando seaborn e o modelo sns
import seaborn as sns

# Plotando o grafico de dispersão:
sns.scatterplot(x="horas_esperadas", hue="finalizado", y="preco", data=dados)

# Plotando o grafico relativo em relação (coluna) do finalizado:
sns.relplot(x="horas_esperadas", y="preco", hue="finalizado", col="finalizado", data=dados)

"""Criando as bases de dados (modelagem):"""

# Define quais são os dados de X e Y:
x = dados[['horas_esperadas', 'preco']]
y = dados['finalizado']

# Criando as bases de treino e teste com train_test_split
from sklearn.model_selection import train_test_split

# Definindo o tamanho do SEED:
SEED = 20

# Aplicando train_test_split na criação das bases:
treino_x, teste_x, treino_y, teste_y = train_test_split(x, y,
                  random_state = SEED,
                  test_size = 0.30,
                  stratify = y
                  )

# Apresentação do resultado das bases (tamanho):
print(f"Treino: {len(treino_x)} - Teste: {len(teste_x)}")

"""# TREINAMENTO

Criado as bases de treino_x, treino_y, teste_x e teste_y ocorre a "escolha" do modelo e aplicação nas bases:
"""

# Importação do LinearSVC - VAMOS DESCONSIDERAR OUTROS MODELOS E INDUZIR A ERRO:
from sklearn.svm import LinearSVC

# Definição e Treino do modelo:
modelo = LinearSVC()
modelo.fit(treino_x, treino_y)

"""# TESTE

Testando o modelo:
"""

# Aplicanod predict nessa informação para que o algoritmo seja submetido em teste:
previsoes = modelo.predict(teste_x)

"""# ACURACIA

Acuracia do modelo - obtendo o valor de precisão do mesmo:
"""

# Importando a lib de accuracy_score:
from sklearn.metrics import accuracy_score

# Aplico o accuracy_score e obtenho o resultado:
acuracia = accuracy_score(teste_y, previsoes)*100

# Apresenta o valor obtido:
print(f"Acuracia: {acuracia:.2f}")

"""Analisando a quantidade de valores:"""

# Conta quantos itens 0 e 1 tem no teste_y:
print("Quantidade no TESTE-Y:")
teste_y.value_counts()

# Conta quantos itens 0 e 1 tem no treino_y:
print("Quantidade no TREINO-Y:")
treino_y.value_counts()

"""# ANALISE DOS RESULTADOS (DETALHAMENTO):

Criar uma base de dados com tudo 1 (tudo finalizado) a fim de reparar a diferença.
"""

# Importar a lib NumPy
import numpy as np

# Criando uma matriz de previsão com tudo 1 nos 648 testes:
previsoes_base = np.ones(648)

# Testar a acuracia com o modelo criado "tudo 1":
acuracia_teste = accuracy_score(teste_y, previsoes)
print(f"Acuracia: {acuracia_teste*100:.2f}%")

sns.scatterplot(x="horas_esperadas", y="preco", hue=teste_y, data=teste_x)

"""Determinando o X e Y min e max para os dados de treino:"""

x_min = teste_x.horas_esperadas.min()
x_max = teste_x.horas_esperadas.max()
y_min = teste_x.preco.min()
y_max = teste_x.preco.max()

print(f"Xmin: {x_min} / Xmax: {x_max} - Horas Esperadas")
print(f"Ymin: {y_min} / Ymax: {y_max} - Preço")

"""Criando uma matrix para visualização da curva de decisão:"""

# Definir a resolução de pixel (ponto a serem analisados
# entre os min e max)
pixels = 100

# Calcular um range entre os valores (min e max - X e Y)
# a fim de serem analisados:
eixo_x = np.arange(x_min, x_max, (x_max - x_min)/pixels)
eixo_y = np.arange(y_min, y_max, (y_max - y_min)/pixels)

# Juntando os pontos X e Y para obter o grid:
xx, yy = np.meshgrid(eixo_x, eixo_y)
pontos = np.c_[xx.ravel(), yy.ravel()]
pontos

"""Refazendo a predição com os pontos:"""

# Fazendo a predição dos pontos:
Z = modelo.predict(pontos)

# Redimencionar os pontos 100 x 100:
Z = Z.reshape(xx.shape)

"""Plotando a curva de decisão:"""

# importando a Lib matplot e modulo plt
import matplotlib.pyplot as plt

# Plotagem Scatter
plt.contourf(xx, yy, Z, alpha=0.3)
plt.scatter(teste_x.horas_esperadas, teste_x.preco, c=teste_y, s=1)
