import psutil
import time
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.linear_model import LinearRegression
from datetime import datetime

data = []

# Coleta de dados
for _ in range(60):  # coleta por 1 min (1s intervalo)
    cpu = psutil.cpu_percent()
    mem = psutil.virtual_memory().percent
    timestamp = datetime.now().strftime("%H:%M:%S")
    data.append([timestamp, cpu, mem])
    time.sleep(1)

# Salvando dados
df = pd.DataFrame(data, columns=["Time", "CPU", "Memory"])
df.to_csv("monitoramento.csv", index=False)

# Gráficos
plt.plot(df["CPU"], label="CPU")
plt.plot(df["Memory"], label="Memória")
plt.legend()
plt.title("Uso de CPU e Memória")
plt.xlabel("Tempo (s)")
plt.ylabel("% Uso")
plt.savefig("grafico_monitoramento.png")
plt.close()

# -*- coding: utf-8 -*-
"""IAAM_250401_Analise_de_Inadimplência_Bancaria.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_gE-n2_oO2oG5dW96dx3si3MPYKT86nq
"""

# 01 - IMPORTAÇÃO DA BASE DE DADOS:

# Importação das Libs / Modulos:
import pandas as pd

# Importação da Base de Dados:
URL = "https://raw.githubusercontent.com/profviniciusheltai/AulaIA/refs/heads/main/base_financiamento_50mil.csv"
df = pd.read_csv(URL)

# Visualização Inicial dos Dados:
display(df.head())
print(df['inadimplente'].value_counts())

# 02 - PRE-VISUALIZAÇÃO DOS DADOS (GRAFICOS):

# Importação das Libs / Modulos:
import matplotlib.pyplot as plt
import seaborn as sns

# Grafico - Distribuição de Inadiplentes:
plt.figure(figsize=(6,4))
sns.countplot(data=df, x='inadimplente')
plt.title("Distribuição de Inadimplência")
plt.xlabel("Inadimplente (0 = Não, 1 = Sim)")
plt.ylabel("Quantidade")
plt.show()

# Grafico - Dispersão: Score x Valor do Financiamento:
plt.figure(figsize=(8,6))
sns.scatterplot(data=df, x='score_credito', y='valor_financiamento', hue='inadimplente')
plt.xlabel("Credito Score")
plt.ylabel("Valor Financiamento [R$]")
plt.show()

# Grafico - Mapa de Correlação:
plt.figure(figsize=(10,6))
sns.heatmap(df.corr(), annot=True, cmap='coolwarm')
plt.title("Mapa de Correlação das Variaveis")
plt.show()

# Grafico - Grafico de Pares (Amostras):
sns.pairplot(df.sample(1000), hue='inadimplente')
plt.suptitle("Grafico de Pares (Amostra)", y=1.02)
plt.show()

# 03 - CRIAÇÃO DA BASE (TREINO / TESTE)

# Importação das Libs / Modulos:
import numpy as np
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split
from sklearn.model_selection import cross_val_score

# Separar dados:
x = df.drop('inadimplente', axis=1)
y = df['inadimplente']

# Normalização (Pre-Processamento):
scaler = StandardScaler()
scaled_x = scaler.fit_transform(x)

# Criação das Bases de Treino / Teste:
treino_x, teste_x, treino_y, teste_y = train_test_split(
    scaled_x, y, test_size=0.3, random_state=42)

# Verificação Final da Base:
print(teste_x)
print(teste_y)

# 04 - AVALIAÇÃO DOS MODELOS:

# Importação das Libs/Modulos:
from sklearn.metrics import accuracy_score
from sklearn.metrics import classification_report
from sklearn.metrics import confusion_matrix

# Função que vai analisar os modelos (avaliar):
def avaliar_modelo(modelo, nome):
  modelo.fit(treino_x, treino_y)
  predicao_y = modelo.predict(teste_x)

  # Apresentando os resultados:
  print("****************************************** ")
  print(f"\n Modelo: {nome} \n -------------------- \n")
  print(" -> Acuracia:", round(accuracy_score(teste_y, predicao_y), 4))
  print(" -> Relatorio de Classificação: \n", classification_report(teste_y, predicao_y))
  print(" -> Matriz de Confusão: \n", confusion_matrix(teste_y, predicao_y))

  scores = cross_val_score(modelo, scaled_x, y, cv=5)
  print(" -> Validação Cruzada (5-fold):", scores)
  print(" -> Media da CV: ", round(scores.mean(), 4))

# Entrada dos Modelos para Avaliação:

# Importação das Libs/Modulos:
from sklearn.linear_model import LogisticRegression
from sklearn.neighbors import KNeighborsClassifier
from sklearn.tree import DecisionTreeClassifier
from sklearn.ensemble import RandomForestClassifier

# Aplicação da Avaliação dos Modelos:
avaliar_modelo(LogisticRegression(), "Regressão Logistica")
avaliar_modelo(KNeighborsClassifier(n_neighbors=5), "KNN")
avaliar_modelo(DecisionTreeClassifier(), "Árvore de Decisão")

RandomForest = RandomForestClassifier(n_estimators = 100, random_state = 42)
avaliar_modelo(RandomForest, "Random Forest")

# 05 - ESCOLHA DO MODELO PARA PREDIÇÃO:

# Escolhendo o modelo de Predição para o Projeto:
modelo = RandomForestClassifier(n_estimators = 100, random_state = 42)
modelo.fit(treino_x, treino_y)




